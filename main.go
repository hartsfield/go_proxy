package main

import (
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
)

var proxyMap = make(map[string]*httputil.ReverseProxy)

// If you want to modify this proxy for a different set of websites, follow the
// bellow pattern. origin, director, proxyMap
func init() {
	//////// MysteryGift.org (TLS) running on port 8050
	originMysteryGift, _ := url.Parse("https://localhost:8050/")
	directorMysteryGift := func(req *http.Request) {
		req.Header.Add("X-Forwarded-Host", req.Host)
		req.Header.Add("X-Origin-Host", originMysteryGift.Host)
		req.URL.Scheme = "http"
		req.URL.Host = originMysteryGift.Host
	}

	proxyMap["mysterygift.org"] =
		&httputil.ReverseProxy{Director: directorMysteryGift}

		//////// TagMachine.TeleSoft.network running on port 8050
	originTagMachine, _ := url.Parse("http://localhost:9001/")
	directorTagMachine := func(req *http.Request) {
		req.Header.Add("X-Forwarded-Host", req.Host)
		req.Header.Add("X-Origin-Host", originTagMachine.Host)
		req.URL.Scheme = "http"
		req.URL.Host = originTagMachine.Host
	}

	// proxyMap["beta.mysterygift.org"] =
	// 	&httputil.ReverseProxy{Director: directorTagMachine}

	///////// TeleSoft.network running on port 9002
	originTeleSoft, _ := url.Parse("http://localhost:9002/")
	directorTeleSoft := func(req *http.Request) {
		req.Header.Add("X-Forwarded-Host", req.Host)
		req.Header.Add("X-Origin-Host", originTeleSoft.Host)
		req.URL.Scheme = "http"
		req.URL.Host = originTeleSoft.Host
	}

	proxyMap["telesoft.network"] =
		&httputil.ReverseProxy{Director: directorTeleSoft}
	proxyMap["tagmachine.telesoft.network"] =
		&httputil.ReverseProxy{Director: directorTagMachine}

		///////// tonedef.TeleSoft.network running on port 9003
	originToneDef, _ := url.Parse("http://localhost:9003/")
	directorToneDef := func(req *http.Request) {
		req.Header.Add("X-Forwarded-Host", req.Host)
		req.Header.Add("X-Origin-Host", originToneDef.Host)
		req.URL.Scheme = "http"
		req.URL.Host = originToneDef.Host
	}

	proxyMap["tonedef.telesoft.network"] =
		&httputil.ReverseProxy{Director: directorToneDef}

}

func main() {
	// run entryPoint() when people visit the server
	http.HandleFunc("/", entryPoint)

	// Start a TLS (HTTPS) server, with links to files generated by
	// letsencrypt.
	// NOTE: Make sure these files have the correct permissions, you likely
	// copied them from root.
	go http.ListenAndServeTLS(":8443", os.Getenv("fullchain"), os.Getenv("privkey"), nil)

	// start an http server
	log.Fatal(http.ListenAndServe(":8080", http.HandlerFunc(upgradeToTLS)))
}

func entryPoint(w http.ResponseWriter, r *http.Request) {
	// check the host name and make sure it exists in our proxyMap. the
	// redirect the user to the appropriate port
	if host, ok := proxyMap[r.Host]; ok {
		host.ServeHTTP(w, r)
		return
	}
	// else redirect the user to the not found page
	notFound(w, r)
}

// check if the hostname is upgradeable to TLS. At this time only MysteryGift
// is upgradeable because I've only generated certificates for it.
func upgradeToTLS(w http.ResponseWriter, r *http.Request) {
	if r.Host == "mysterygift.org" || r.Host == "telesoft.network" || r.Host == "tagmachine.telesoft.network" {
		target := "https://" + r.Host + r.URL.Path
		if len(r.URL.RawQuery) > 0 {
			target += "?" + r.URL.RawQuery
		}
		http.Redirect(w, r, target, http.StatusTemporaryRedirect)
	} else {
		entryPoint(w, r)
	}
}

// If this user tries to visit a host that can't be found, we send a message
func notFound(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("coming soon"))
}
